import type {
  Table,
  Column,
  Relationship,
  TableSpecification,
  ColumnSpecification,
  ConstraintSpecification,
  IndexSpecification,
  TableStatistics,
  SpecificationSummary,
} from '@biagram/shared';
import { analyzeTableRelationships, calculateRelationshipStats } from './relationship-analyzer.js';
import { buildSearchText } from './search-text-builder.js';

/**
 * Specification Generator
 *
 * DBML 파싱 결과(Table[])를 받아서 TableSpecification으로 변환합니다.
 */

export interface GeneratorOptions {
  includeSearchText?: boolean;
  includeStatistics?: boolean;
  autoGenerateDescriptions?: boolean;
}

const DEFAULT_OPTIONS: Required<GeneratorOptions> = {
  includeSearchText: true,
  includeStatistics: true,
  autoGenerateDescriptions: false,
};

/**
 * 단일 테이블 명세서 생성
 */
export function generateTableSpecification(
  table: Table,
  allRelationships: Relationship[],
  options: GeneratorOptions = {}
): TableSpecification {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // 1. 컬럼 정보 변환 (테이블 이름 전달하여 FK 정확히 판별)
  const fullTableName = table.schema ? `${table.schema}.${table.name}` : table.name;
  
  // Unique 인덱스에 포함된 컬럼 목록 추출 (컬럼 순서 기준으로 번호 부여)
  // 1단계: 각 컬럼이 어떤 인덱스에 속하는지 매핑 (인덱스 ID 사용)
  const columnToIndexId = new Map<string, number>(); // 컬럼명 → 인덱스 ID
  let indexId = 0;
  if (table.indexes && table.indexes.length > 0) {
    for (const idx of table.indexes) {
      if (idx && idx.unique && idx.columns && idx.columns.length > 0) {
        for (const col of idx.columns) {
          if (col && !columnToIndexId.has(col)) {
            columnToIndexId.set(col, indexId);
          }
        }
        indexId++;
      }
    }
  }
  const totalUniqueIndexCount = indexId;

  // 2단계: 컬럼 순서대로 순회하면서 UK 번호 부여
  const indexIdToNumber = new Map<number, number>(); // 인덱스 ID → UK 번호
  let ukNumber = 1;
  const uniqueIndexColumns = new Map<string, number>(); // 컬럼명 → UK 번호

  for (const col of table.columns) {
    const idxId = columnToIndexId.get(col.name);
    if (idxId !== undefined) {
      if (!indexIdToNumber.has(idxId)) {
        // 이 인덱스가 처음 등장 → 새 번호 부여
        indexIdToNumber.set(idxId, ukNumber);
        ukNumber++;
      }
      uniqueIndexColumns.set(col.name, indexIdToNumber.get(idxId)!);
    }
  }
  
  const columns = table.columns.map((col) => convertColumn(col, fullTableName, allRelationships, uniqueIndexColumns, totalUniqueIndexCount));

  // 2. 제약 조건 추출
  const constraints = extractConstraints(table, allRelationships);

  // 3. 인덱스 정보
  const indexes: IndexSpecification[] = (table.indexes || []).map((idx) => ({
    name: idx.name || (idx.columns || []).join(', '), // Use original name or column list
    columns: idx.columns || [],
    unique: idx.unique || false,
  }));

  // 4. 관계 분석 (스키마 포함 전체 이름으로 검색)
  const relationships = analyzeTableRelationships(fullTableName, allRelationships);
  const relationshipStats = calculateRelationshipStats(relationships);

  // 5. 통계 계산
  const stats: TableStatistics = {
    columnCount: columns.length,
    primaryKeyCount: columns.filter((c) => c.primaryKey).length,
    foreignKeyCount: columns.filter((c) => c.foreignKey).length,
    uniqueKeyCount: columns.filter((c) => c.unique).length,
    indexCount: indexes.length,
    relationshipCount: relationshipStats.totalCount,
    incomingRelationships: relationshipStats.incomingCount,
    outgoingRelationships: relationshipStats.outgoingCount,
  };

  // 6. 검색 텍스트 생성
  const searchableText = opts.includeSearchText
    ? buildSearchText(table)
    : '';

  // 7. 태그 및 카테고리 (향후 확장)
  const tags: string[] = [];
  const category: string | undefined = undefined;

  // 8. 타임스탬프
  const now = new Date();

  return {
    id: table.id,
    tableName: table.name,
    schemaName: table.schema,
    alias: table.alias,
    description: table.note,
    note: table.note,
    columns,
    constraints,
    indexes,
    relationships,
    stats,
    searchableText,
    tags,
    category,
    createdAt: now,
    updatedAt: now,
  };
}

/**
 * 여러 테이블의 명세서 일괄 생성
 */
export function generateSpecifications(
  tables: Table[],
  relationships: Relationship[],
  options: GeneratorOptions = {}
): TableSpecification[] {
  return tables.map((table) =>
    generateTableSpecification(table, relationships, options)
  );
}

/**
 * 명세서 요약 정보 생성 (목록용)
 */
export function generateSpecificationSummary(
  spec: TableSpecification
): SpecificationSummary {
  return {
    id: spec.id,
    tableName: spec.tableName,
    schemaName: spec.schemaName,
    description: spec.description,
    columnCount: spec.stats.columnCount,
    relationshipCount: spec.stats.relationshipCount,
    indexCount: spec.stats.indexCount,
    hasIndexes: spec.stats.indexCount > 0,
    hasForeignKeys: spec.stats.foreignKeyCount > 0,
    tags: spec.tags,
    category: spec.category,
    updatedAt: spec.updatedAt,
  };
}

/**
 * Column → ColumnSpecification 변환
 */
function convertColumn(
  column: Column,
  tableName: string,
  allRelationships: Relationship[],
  uniqueIndexColumns: Map<string, number>,
  totalUniqueIndexCount: number
): ColumnSpecification {
  // 타입 정보 추출 (크기 포함)
  const typeStr = formatColumnType(column.type);

  // 외래 키 정보 찾기 (테이블 이름도 전달하여 정확히 판별)
  const foreignKey = findForeignKeyForColumn(column, tableName, allRelationships);

  // Unique 여부: 컬럼 자체 속성 또는 unique 인덱스에 포함된 경우
  const isUnique = column.unique || uniqueIndexColumns.has(column.name);
  
  // UK가 2개 이상일 때만 번호 부여
  const uniqueIndexNumber = totalUniqueIndexCount >= 2 
    ? uniqueIndexColumns.get(column.name) 
    : undefined;

  return {
    name: column.name,
    type: typeStr,
    nullable: column.nullable ?? true,
    primaryKey: column.primaryKey ?? false,
    unique: isUnique,
    uniqueIndexNumber,
    autoIncrement: column.autoIncrement ?? false,
    defaultValue: column.defaultValue ? String(column.defaultValue) : undefined,
    description: column.note,
    foreignKey,
  };
}

/**
 * 컬럼 타입을 문자열로 포맷팅 (크기 정보 포함)
 */
function formatColumnType(type: Column['type']): string {
  if (typeof type === 'string') {
    return type;
  }

  if (!type || !type.name) {
    return 'unknown';
  }

  // 크기 정보를 모은다
  const parts: (number | string)[] = [];

  // size가 있으면 (예: varchar(100))
  if (type.size !== undefined) {
    parts.push(type.size);
  }

  // precision과 scale이 있으면 (예: decimal(18,2))
  if (type.precision !== undefined) {
    parts.push(type.precision);
    if (type.scale !== undefined) {
      parts.push(type.scale);
    }
  }

  // 기타 파라미터들
  if (type.parameters && type.parameters.length > 0) {
    parts.push(...type.parameters);
  }

  // 크기 정보가 있으면 포함
  if (parts.length > 0) {
    return `${type.name}(${parts.join(', ')})`;
  }

  return type.name;
}

/**
 * 컬럼의 외래 키 정보 찾기
 */
function findForeignKeyForColumn(
  column: Column,
  tableName: string,
  allRelationships: Relationship[]
): ColumnSpecification['foreignKey'] {
  // column.references가 있으면 사용
  if (column.references) {
    return {
      referencedTable: column.references.table,
      referencedColumn: column.references.column,
    };
  }

  // relationships에서 찾기 (테이블 이름과 컬럼 이름 모두 일치해야 함)
  for (const rel of allRelationships) {
    if (rel.fromTable === tableName && rel.fromColumn === column.name) {
      return {
        referencedTable: rel.toTable,
        referencedColumn: rel.toColumn,
        onUpdate: rel.onUpdate,
        onDelete: rel.onDelete,
      };
    }
  }

  return undefined;
}

/**
 * 테이블의 제약 조건 추출
 */
function extractConstraints(
  table: Table,
  allRelationships: Relationship[]
): ConstraintSpecification[] {
  const constraints: ConstraintSpecification[] = [];

  // 1. Primary Key
  const primaryKeys = table.columns
    .filter((c) => c.primaryKey)
    .map((c) => c.name);

  if (primaryKeys.length > 0) {
    constraints.push({
      type: 'primary_key',
      name: `pk_${table.name}`,
      columns: primaryKeys,
    });
  }

  // 2. Unique Keys
  const uniqueColumns = table.columns.filter((c) => c.unique);
  for (const col of uniqueColumns) {
    constraints.push({
      type: 'unique',
      name: `uq_${table.name}_${col.name}`,
      columns: [col.name],
    });
  }

  // 3. Foreign Keys
  for (const rel of allRelationships) {
    if (rel.fromTable === table.name) {
      constraints.push({
        type: 'foreign_key',
        name: `fk_${rel.fromTable}_${rel.fromColumn}`,
        columns: [rel.fromColumn],
        referencedTable: rel.toTable,
        referencedColumns: [rel.toColumn],
        onUpdate: rel.onUpdate,
        onDelete: rel.onDelete,
      });
    }
  }

  return constraints;
}

/**
 * 여러 명세서를 요약 정보로 변환
 */
export function generateSummaries(
  specs: TableSpecification[]
): SpecificationSummary[] {
  return specs.map(generateSpecificationSummary);
}

/**
 * 특정 테이블의 명세서 찾기
 */
export function findSpecification(
  specs: TableSpecification[],
  tableName: string
): TableSpecification | undefined {
  return specs.find(
    (spec) =>
      spec.tableName === tableName ||
      spec.alias === tableName
  );
}

/**
 * 명세서 정렬
 */
export function sortSpecifications(
  specs: TableSpecification[],
  sortBy: 'name' | 'columnCount' | 'relationshipCount' | 'updatedAt',
  order: 'asc' | 'desc' = 'asc'
): TableSpecification[] {
  const sorted = [...specs].sort((a, b) => {
    let comparison = 0;

    switch (sortBy) {
      case 'name':
        comparison = a.tableName.localeCompare(b.tableName);
        break;
      case 'columnCount':
        comparison = a.stats.columnCount - b.stats.columnCount;
        break;
      case 'relationshipCount':
        comparison = a.stats.relationshipCount - b.stats.relationshipCount;
        break;
      case 'updatedAt':
        comparison = a.updatedAt.getTime() - b.updatedAt.getTime();
        break;
    }

    return order === 'asc' ? comparison : -comparison;
  });

  return sorted;
}

/**
 * 명세서 필터링
 */
export function filterSpecifications(
  specs: TableSpecification[],
  filters: {
    schemas?: string[];
    tags?: string[];
    hasRelationships?: boolean;
    hasForeignKeys?: boolean;
    hasIndexes?: boolean;
  }
): TableSpecification[] {
  return specs.filter((spec) => {
    // Schema filter
    if (filters.schemas && filters.schemas.length > 0) {
      if (!spec.schemaName || !filters.schemas.includes(spec.schemaName)) {
        return false;
      }
    }

    // Tags filter
    if (filters.tags && filters.tags.length > 0) {
      if (!spec.tags || !filters.tags.some((tag) => spec.tags?.includes(tag))) {
        return false;
      }
    }

    // Relationships filter
    if (filters.hasRelationships !== undefined) {
      if (filters.hasRelationships && spec.stats.relationshipCount === 0) {
        return false;
      }
      if (!filters.hasRelationships && spec.stats.relationshipCount > 0) {
        return false;
      }
    }

    // Foreign keys filter
    if (filters.hasForeignKeys !== undefined) {
      if (filters.hasForeignKeys && spec.stats.foreignKeyCount === 0) {
        return false;
      }
      if (!filters.hasForeignKeys && spec.stats.foreignKeyCount > 0) {
        return false;
      }
    }

    // Indexes filter
    if (filters.hasIndexes !== undefined) {
      if (filters.hasIndexes && spec.stats.indexCount === 0) {
        return false;
      }
      if (!filters.hasIndexes && spec.stats.indexCount > 0) {
        return false;
      }
    }

    return true;
  });
}
